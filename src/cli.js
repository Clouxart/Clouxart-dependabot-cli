'use strict'

import arg from 'arg';
import inquirer from 'inquirer';
import path from 'path';
import fs from 'fs';

const defaultRootPath = './';
const dependabotFileName = 'dependabot.yml'
const dependabotFileNamePath = '.github/'

const defaultExcludedPaths = ['node_modules/', '.git/'];
const supportedPackageManagers = [
  { name: 'npm', filter: 'package.json', checked: true, packageFiles: [] },
  { name: 'nuget', filter: '.csproj', checked: true, packageFiles: [] }
];

function parseArgumentsIntoOptions(rawArgs) {
  const args = arg(
    {
      '--yes': Boolean,
      '--excluded-paths': Array,
      '--package-managers': Array,
      '-y': '--yes',
      '-e': '--excluded-paths',
      '-p': '--package-managers',
    },
    {
      argv: rawArgs.slice(2),
    }
  );
  return {
    skipPrompts: args['--yes'] || false,
    excludedPaths: args['--excluded-paths'],
    packageManagers: args['--package-managers'],
    rootPath: args._[0],
  };
}

async function promptForMissingOptions(options) {
  if (options.skipPrompts) {
    return {
      ...options,
      excludedPaths: options.excludedPaths || defaultExcludedPaths,
      packageManagers: options.packageManagers || supportedPackageManagers.map(i => i.name),
      rootPath: options.rootPath || defaultRootPath,
    };
  }

  const questions = [];
  if (!options.rootPath) {
    questions.push({
      type: 'input',
      name: 'rootPath',
      message: 'Please type projects relative root path',
      default: defaultRootPath,
    });
  }

  if (!options.packageManagers) {
    questions.push({
      type: 'checkbox',
      name: 'packageManagers',
      message: 'Please select package-ecosystems you want dependabot monitor for new versions. \nPS: The repository must also contain a dependency manifest or lock file for each of these package managers.',
      choices: supportedPackageManagers,
      default: supportedPackageManagers,
    });
  }

  if (!options.excludedPaths) {
    questions.push({
      type: 'input',
      name: 'excludedPaths',
      message: 'Please type paths you want to ignore. i.e node_modules/,.git/,myTemp/',
      default: defaultExcludedPaths
    });
  }

  const answers = await inquirer.prompt(questions);
  if (answers.excludedPaths && !Array.isArray(answers.excludedPaths)) {
    answers.excludedPaths = answers.excludedPaths.split(',')
  }

  return {
    ...options,
    excludedPaths: options.excludedPaths || answers.excludedPaths,
    packageManagers: options.packageManagers || answers.packageManagers,
    rootPath: options.rootPath || answers.rootPath
  };
}

const getFiles = async (dirPath) => {
  let entries = await new Promise((success, failure) => {
    fs.readdir(dirPath, { withFileTypes: true }, (err, data) => {
      if (err) {
        console.log(err);
        failure(err);
      }
      else success(data);
    });
  });

  // Get files within the current directory and add a path key to the file objects
  const files = entries.filter((file) => !file.isDirectory()).map((file) => path.join(dirPath, file.name));

  // Get folders within the current directory
  const folders = entries.filter((folder) => folder.isDirectory());

  /*
    Add the found files within the subdirectory to the files array by calling the
    current function itself
  */
  for (const folder of folders) files.push(...(await getFiles(`${path.join(dirPath, folder.name)}/`)));

  return files;
};

const filterFiles = async (files, filterList) => {
  for (let filter of filterList) {
    files = files.filter((fileName) => !fileName.includes(filter));
  }
  return files;
};

const getSelectedPackageManagers = async (options) => {
  let selectedPackageManagers = supportedPackageManagers.filter(r => options.packageManagers.includes(r.name));
  let files = await getFiles(options.rootPath).then(files => filterFiles(files, options.excludedPaths));

  for (const packageManager of selectedPackageManagers) {
    console.log(`Adding ${packageManager.name} packages`);
    packageManager.packageFiles = files.filter((fileName) => fileName.endsWith(packageManager.filter));
  }

  return selectedPackageManagers;
}

async function generateConfigFile(options) {
  let selectedPackageManagers = await getSelectedPackageManagers(options);

  let yaml_file = `# This files was generated by dependabot-cli
# https://www.npmjs.com/package/dependabot
version: 2
updates:`;

  for (const packageManager of selectedPackageManagers) {
    packageManager.packageFiles.forEach((packageFile) => {
      let packageFilePath = packageFile
        .substring(0, packageFile.lastIndexOf('/'))
        .replace(options.rootPath, './');

      yaml_file =
        yaml_file + `
  - package-ecosystem: ${packageManager.name}
    directory: ${packageFilePath || '.'}
    schedule:
      interval: "daily"`;
    });
  }

  return yaml_file;
}

async function createConfigFile(rootPath, configYml) {
  let configFilePath = path.join(rootPath, dependabotFileNamePath);
  let configFile = path.join(configFilePath, dependabotFileName);

  fs.mkdirSync(configFilePath, { recursive: true });
  fs.writeFile(configFile, configYml, function (err) {
    if (err) {
      return console.log(err);
    }
    console.log(`${configFile} was saved!`);
  });
}

export async function cli(args) {
  let options = parseArgumentsIntoOptions(args);
  options = await promptForMissingOptions(options);
  console.log(options);

  let configYml = await generateConfigFile(options);
  await createConfigFile(options.rootPath, configYml)
}
